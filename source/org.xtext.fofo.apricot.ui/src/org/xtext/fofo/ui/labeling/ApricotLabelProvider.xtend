/*
* generated by Xtext
*/
package org.xtext.fofo.ui.labeling

import com.google.inject.Inject
import org.eclipse.xtext.ui.label.DefaultEObjectLabelProvider;
import org.xtext.fofo.apricot.Field
import org.xtext.fofo.apricot.Method
import org.xtext.fofo.apricot.CompositionMethod
import org.xtext.fofo.apricot.ControlSwitchComposition
import org.xtext.fofo.apricot.ConstructorMethod
import org.xtext.fofo.apricot.ContinuousMethod
import org.xtext.fofo.apricot.DiscreteMethod
import org.xtext.fofo.apricot.InitMethod
import org.xtext.fofo.apricot.InvariantBlock
import org.xtext.fofo.apricot.ConditionBlock
import org.xtext.fofo.apricot.DiscreteBlock
import org.xtext.fofo.apricot.Import
import org.xtext.fofo.apricot.PackageDeclaration
import org.xtext.fofo.apricot.AbstractCompositionMethod
import org.xtext.fofo.apricot.AbstractMethod
import org.xtext.fofo.apricot.Requires
import org.xtext.fofo.apricot.AbstractDiscreteMethod
import org.xtext.fofo.apricot.ClockConstraint
import org.xtext.fofo.apricot.AbstractContinuousMethod
import org.xtext.fofo.apricot.AbstractInvariant
import org.xtext.fofo.apricot.AbstractInitMethod
import org.xtext.fofo.apricot.RequiresAbstractComposition
import java.util.ListIterator
import org.xtext.fofo.apricot.Parameter
import java.util.List
import org.eclipse.emf.common.util.EList
import org.xtext.fofo.apricot.BasicType
import org.xtext.fofo.apricot.RefType
import org.xtext.fofo.apricot.Class
import org.xtext.fofo.apricot.Interface
import org.eclipse.emf.ecore.EObject
import org.xtext.fofo.apricot.Member

/**
 * Provides labels for a EObjects.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#labelProvider
 */
class ApricotLabelProvider extends DefaultEObjectLabelProvider {

	@Inject
	new(org.eclipse.emf.edit.ui.provider.AdapterFactoryLabelProvider delegate) {
		super(delegate);
	}
	
	
	def image(org.xtext.fofo.apricot.Class element) {
		return "class_obj.gif";
	}
	
	def image(org.xtext.fofo.apricot.Interface element) {
		return "interface_obj.gif";
	}
	
	def image(Field element) {
		return "field.gif";
	}
	
	def image(Method element) {
		return "methobj.gif";
	}
	
	def image(AbstractMethod element) {
		return "methobj.gif";
	}
	
	def image(CompositionMethod elemenet){
		return "methobj.gif";
	}
	
	def image(AbstractCompositionMethod elemenet){
		return "methobj.gif";
	}
	
	def image(ControlSwitchComposition element){
		return "methdef.gif";
	}
	
	def image(ConstructorMethod element) {
		return "methobj.gif";
	}
	
	def image(ContinuousMethod element){
		return "methobj.gif";
	}
	
	def image(AbstractContinuousMethod element){
		return "methobj.gif";
	}
	
	def image(DiscreteMethod element){
		return "methobj.gif";
	}
	
	def image(AbstractDiscreteMethod element){
		return "methobj.gif";
	}
	
	def image(ClockConstraint element){
		return "clock.png";
	}
	
	
	def image(InitMethod element){
		return "methobj.gif";
	}
	
	
	def image(AbstractInitMethod element){
		return "methobj.gif";
	}
	
	def image(InvariantBlock element){
		return "block.gif";
	}
	
	def image(AbstractInvariant element){
		return "block.gif";
	}
	
	def image(ConditionBlock element){
		return "conditionblock.gif";
	}
	
	def image(DiscreteBlock element){
		return "discreteblock.gif";
	}
	
	
	
	
	def image(Import element){
		return "imports.png";
	}
	
	def image(PackageDeclaration element){
		return "Package.png";
	}
	
	def image(Requires element){
		return "requires.gif";
	}
	
	def image(RequiresAbstractComposition element){
		return "requires.gif";
	}
	
	def text(Method m) {
		if(m.type.reftype != null){
			return m.getName() + " : "
				+ getText(m.type.reftype);
		}		
		else{
			return m.getName() + " : "
				+ getText(m.type.type);
		}
		
	}
	
	
	
	
	
	def text(Class type){
		return type.getName();
	}
	
	def text(Interface type){
		return type.getName();
	}
	
	// Labels and icons can be computed like this:
	
//	def text(Greeting ele) {
//		'A greeting to ' + ele.name
//	}
//
//	def image(Greeting ele) {
//		'Greeting.gif'
//	}
}
